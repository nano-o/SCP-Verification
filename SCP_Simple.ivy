#lang ivy1.7

include order

type node
relation intact(N:node)

type quorum

relation member(N:node, Q:quorum)
type bset # blocking sets
relation bset_member(N:node, B:bset)
relation blocking(N:node, B:bset)

instance value : bounded_sequence(nat)
instance round : bounded_sequence(nat)

type ballot = struct {
    n:round,
    x:value
}

# TODO: this does not seem to work:
# type statement = {abort, commit}
type statement
individual commit:statement
individual abort:statement
trusted isolate commit_abort_iso = {
    property commit ~= abort
    property X = commit | X = abort 
}

# those are the properties of quorums and blocking sets that we rely on:
trusted isolate fbas_axiomatization = {
    axiom (exists N1 . intact(N1) & member(N1,Q1)) & (exists N2 . intact(N2)  & member(N2,Q2)) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2) # note that intersection at a well-behaved node would not suffice
    axiom (exists N . intact(N) & blocking(N,BL)) -> exists N2 . intact(N2) & bset_member(N2,BL)
}

isolate ballot_order = {
    definition (B1 < B2) = (n(B1) < n(B2)) | (n(B1) = n(B2) & x(B1) < x(B2))
    definition (B1:ballot <= B2) = (B1 < B2 | B1 = B2)
    instantiate totally_ordered(ballot)
} with value, round

isolate simple_ballot_protocol = {
    
    relation vote(N:node, B:ballot, S:statement)
    relation accept(N:node, B:ballot, S:statement)
    relation confirm(N:node, B:ballot, S:statement)

    # ghost vars:
    individual accepted:bool
    individual the_b:ballot

    ## Invariants
    # note that invariants do not say anything about ill-behaved or befouled nodes; therefore we do not bother to model their behavior

    invariant [safety] ~(intact(N1) & intact(N2) & confirm(N1,B1,commit) & confirm(N2,B2,commit) & x(B1) ~= x(B2))

    private {
        # the main invariant:
        invariant (exists N . intact(N) & vote(N,B2,commit)) & B1 < B2 & x(B1) ~= x(B2) ->
        ((exists N . intact(N) & accept(N,B1,abort)) | (accepted & the_b <= B1 & x(the_b) = x(B2)))
        
        invariant accepted -> (exists N . intact(N) & accept(N,the_b,commit))
        
        # validity properties; edge from ballot and statement to node
        invariant (exists N . intact(N) & accept(N,B,S)) -> (exists N2 . intact(N2) & vote(N2,B,S))
        invariant (exists N . intact(N) & confirm(N,B,S)) -> (exists N2 . intact(N2) & vote(N2,B,S))

        # an intact node does not cast contradictory votes
        invariant ~(intact(N) & vote(N,B,S1) & vote(N,B,S2) & S1 ~= S2)

        # federated_voting invariants:
        invariant ~(intact(N1) & intact(N2) & accept(N1,B1,S1) & accept(N2,B1,S2) & S1 ~= S2)
        invariant ~(intact(N1) & intact(N2) & confirm(N1,B1,S1) & confirm(N2,B1,S2) & S1 ~= S2)

        invariant ~(intact(N1) & vote(N1,B,S1) & vote(N1,B,S2) & S1 ~= S2)
        
        invariant (exists N1 . intact(N1) & accept(N1,B1,S1)) -> exists Q . (exists N3 . intact(N3) & member(N3,Q)) & (forall N2 . intact(N2) & member(N2, Q) -> vote(N2,B1,S1))
        invariant (exists N1 . intact(N1) & confirm(N1,B1,S1)) -> exists Q . (exists N1 . intact(N1) & member(N1,Q)) & forall N2 . intact(N2) & member(N2,Q) -> accept(N2,B1,S1)
    }
    
    after init {
        vote(N,B,S) := false;
        accept(N,B,S) := false;
        confirm(N,B,S) := false;
	accepted := false;
    }

    action vote_abort(n:node, b:ballot) = {
	require intact(n);
        require ~(vote(n,b,S) & S ~= abort);
        vote(n,b,abort) := true;
    }
    
    action vote_commit(n:node, b:ballot) = {
	require intact(n);
        require B < b & x(B) ~= x(b) -> confirm(n,B,abort);
        require ~(vote(n,b,S) & S ~= commit);
        vote(n,b,commit) := true;
    }

    relation condition_accept(N:node, B:ballot, S:statement)
    definition condition_accept(v:node,b:ballot,s:statement) =
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,b,s) | accept(N,b,s)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,b,s))

    # Allows to vote without preparing when the value has previously been accepted
    action vote_commit_after_accept(v:node, b:ballot) = {
	require intact(v);
	require accepted & the_b.n <= b.n & the_b.x = b.x;
	require ~(vote(v,b,S) & S ~= commit);
        vote(v,b,commit) := true;
    }
    
    action do_accept(v:node, b:ballot, s:statement) = {
	require intact(v);
        require condition_accept(v,b,s);
        accept(v,b,s) := true;

        # ghost update:
	if (s = commit & (~accepted | b < the_b)) {
	    accepted := true;
	    the_b := b;
	}
    }

    action do_confirm(n:node, b:ballot, s:statement) = {
	require intact(n);
        require exists Q . member(n,Q) & forall N . member(N,Q) -> accept(N,b,s);
        confirm(n,b,s) := true;
    }

    export vote_abort
    export vote_commit
    export do_accept
    export do_confirm
    export vote_commit_after_accept
    
} with ballot_order, fbas_axiomatization, commit_abort_iso
