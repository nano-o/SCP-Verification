#lang ivy1.7

include order

type node
relation intact(N:node)

type quorum
relation member(N:node, Q:quorum)
type bset # blocking sets
relation bset_member(N:node, B:bset)
relation blocking(N:node, B:bset)

trusted isolate fbas_axiomatization = {
    axiom intact(N1) & intact(N2) & member(N1,Q1) & member(N2,Q2) -> exists N3 . intact(N3) & member(N3,Q1) & member(N3,Q2)
    axiom intact(N) & blocking(N,BL) -> exists N2 . intact(N2) & bset_member(N2,B)
}

instance value : bounded_sequence(nat)
instance round : bounded_sequence(nat)

type ballot = struct {
    n:round,
    x:value
}

# TODO: this does not seem to work:
# type statement = {abort, commit}
type statement
individual commit:statement
individual abort:statement
trusted isolate commit_abort_iso = {
    property commit ~= abort
    property X = commit | X = abort 
}

isolate ballot_order = {
    definition (B1 < B2) = (n(B1) < n(B2)) | (n(B1) = n(B2) & x(B1) < x(B2))
    definition (B1:ballot <= B2) = (B1 < B2 | B1 = B2)
    instantiate totally_ordered(ballot)
} with value, round

individual zero:ballot # the special 0 ballot
isolate ballot_zero_iso = {
    after init {
        zero.n := 0;
        zero.x := 0;
    }
    invariant zero.n = 0 & zero.x = 0
    invariant zero <= B
} with ballot_order, value, round

isolate abstract_protocol = {
            
    relation vote(N:node, B:ballot, S:statement)
    relation accept(N:node, B:ballot, S:statement)
    relation confirm(N:node, B:ballot, S:statement)
    
    # invariants
    # note how invariants talk only about intact nodes
    
    invariant [safety] ~(intact(N1) & intact(N2) & confirm(N1,B1,commit) & confirm(N2,B2,commit) & x(B1) ~= x(B2))

    # intact nodes do not accept different values as committed:
    invariant ~(intact(N1) & intact(N2) & accept(N1,B1,commit) & accept(N2,B2,commit) & x(B1) ~= x(B2))

    # the main invariant (note this is not EPR, as there is a self-loop on ballot; also creates edge from ballot to node):
    invariant (exists N . intact(N) & vote(N,B2,commit)) & B1 < B2 & x(B1) ~= x(B2) ->
        ((exists N . intact(N) & accept(N,B1,abort)) | exists B . B < B1 & x(B) = x(B2) & (exists N . intact(N) & accept(N,B,commit)))

    # validity properties (creates edge from ballot to node):
    invariant (exists N . intact(N) & accept(N,B,S)) -> (exists N . intact(N) & vote(N,B,S))
    invariant (exists N . intact(N) & confirm(N,B,S)) -> (exists N . intact(N) & accept(N,B,S))
    
    # a node does not cast contradictory votes
    invariant ~(intact(N) & vote(N,B,S1) & vote(N,B,S2) & S1 ~= S2)

    # federated_voting invariants:
    invariant ~(intact(N1) & intact(N2) & accept(N1,B1,S1) & accept(N2,B1,S2) & S1 ~= S2)
    invariant ~(intact(N1) & intact(N2) & confirm(N1,B1,S1) & confirm(N2,B1,S2) & S1 ~= S2)
    invariant intact(N1) & accept(N1,B1,S1) -> exists Q . (exists N3 . intact(N3) & member(N3,Q)) & (forall N2 . intact(N2) & member(N2, Q) -> vote(N2,B1,S1))
    invariant intact(N1) & confirm(N1,B1,S1) -> exists Q . member(N1,Q) & forall N2 . intact(N2) & member(N2,Q) -> accept(N2,B1,S1)
    
    after init {
        vote(N,B,S) := false;
        accept(N,B,S) := false;
        confirm(N,B,S) := false;
    }
    
    relation condition_accept(N:node, B:ballot, S:statement)
    definition condition_accept(v:node, b:ballot, s:statement) = # NOTE: can only be applied to constants. TODO: would be nice if we could generalize over B only and then apply it with v and s constants and B quantified.
    (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,b,s) | accept(N,b,s)))
    | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,b,s))

    relation condition_vote(N:node, B:ballot, S:statement)
    definition condition_vote(V:node, B:ballot, S:statement) =
    forall S2 . ~(vote(V,B,S2) & S ~= S2)

    relation condition_confirm(N:node, B:ballot, S:statement)
    definition condition_confirm(V:node, B:ballot, S:statement) = # NOTE: beware alternation
    exists Q . member(V,Q) & forall N . member(N,Q) -> accept(N,B,S)
    
    action send_prepare(v:node, b:ballot, p:ballot, pp:ballot, nc:round, nh:round) = {
        require intact(v); # we do node model other nodes since the invariants do not talk about them
        require nc <= nh;
        require p < pp & p.x ~= pp.x;
        require ~(p ~= 0 & b.x ~= p.x);
        
        require B < b & x(B) ~= x(b) -> (condition_vote(v,B,abort) | ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        ));
        vote(v, B, abort) := vote(v, B, abort) | (B < b & x(B) ~= x(b) & condition_vote(v, B, abort));
        accept(v, B, abort) := accept(v, B, abort) | (B < b & x(B) ~= x(b) & ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        ));
        
        require B < p & x(B) ~= x(p) -> ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        );
        accept(v, B, abort) := accept(v, B, abort) | (B < p & x(B) ~= x(p));
        
        require B < pp & x(B) ~= x(pp) -> ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        );
        accept(v, B, abort) := accept(v, B, abort) | (B < pp & x(B) ~= x(pp));

        var hb:ballot;
        hb.n := nh;
        hb.x := b.x;
        
        if (nc ~= 0) {
            # TODO maybe put next require outside (not required for the ensured properties at the end):
            # NOTE: the following require is subsumed by the update to confirm in the next if block: the node will confirm those ballots, hence making the main invariant true
            require B < hb & x(B) ~= x(hb) -> confirm(v, B, abort);
            require ((nc <= n(B) | n(B) <= nh) & x(B) = x(b)) -> condition_vote(v, B, commit);
            vote(v, B, commit) := vote(v, B, commit) | (nc <= n(B) & n(B) <= nh & x(B) = x(b));
        };

        if (nh ~= 0) {
            require B < hb & x(B) ~= x(hb) -> condition_confirm(v, B, abort);
            confirm(v, B, abort) := confirm(v, B, abort) | (B < hb & x(B) ~= x(hb));
        };
    }

    action send_commit(v:node, b:ballot, np:round, nc:round, nh:round) = {
        require intact(v); # we do node model other nodes since the invariants do not talk about them
        require nc ~= 0 & nh ~= 0;
        
        require nc <= n(B) & n(B) <= nh & x(B) = x(b) -> ( # condition_accept(v,B,commit)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,commit) | accept(N,B,commit)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,commit))
        );
        accept(v, B, commit) := accept(v, B, commit) | (nc <= n(B) & n(B) <= nh & x(B) = x(b));
        
        require x(B) ~= x(b) -> (condition_vote(v,B,abort) | ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        ));
        vote(v, B, abort) := vote(v, B, abort) | (x(B) ~= x(b) & condition_vote(v, B, abort));
        accept(v, B, abort) := accept(v, B, abort) | (x(B) ~= x(b) & ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        ));

        require n(B) < np & x(B) ~= x(b) -> ( # condition_accept(v,B,abort)
        (exists Q . member(v,Q) & forall N . member(N,Q) -> (vote(N,B,abort) | accept(N,B,abort)))
        | (exists BL . blocking(v,BL) & forall N . bset_member(N,BL) -> accept(N,B,abort))
        );
        accept(v, B, abort) := accept(v, B, abort) | (n(B) < np & x(B) ~= x(b));
        # TODO: why not same with pp? Answer: Not necessary.
        
        var hb:ballot;
        hb.n := nh;
        hb.x := b.x;
        require B < hb & x(B) ~= x(hb) -> condition_confirm(v, B, abort);
        confirm(v, B, abort) := confirm(v, B, abort) | (B < hb & x(B) ~= x(hb));

        var cb:ballot;
        cb.n := nc;
        cb.x := b.x;
        require accept(v, cb, commit);
        require nc <= n(B) & x(B) = x(b) -> condition_vote(v, B, commit);
        vote(v, B, commit) := vote(v, B, commit) | (nc <= n(B) & x(B) = x(b));
    }

    action do_accept(n:node, b:ballot, s:statement) = {
        require intact(n);
        require (exists Q . member(n,Q) & forall N . member(N,Q) -> (vote(N,b,s) | accept(N,b,s))) | (exists B . blocking(n,B) & forall N . bset_member(N,B) -> accept(N,b,s));
        accept(n, b, s) := true;
    }

    action do_confirm(n:node, b:ballot, s:statement) = {
        require intact(n);
        require exists Q . member(n,Q) & forall N . member(N,Q) -> accept(N,b,s);
        confirm(n,b,s) := true;
    }

    export send_prepare
    export do_accept
    export do_confirm
    export send_commit
    
} with fbas_axiomatization, value, round, ballot_order, commit_abort_iso
