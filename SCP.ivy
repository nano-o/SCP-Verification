#lang ivy1.7

include order

type node
relation intact(N:node)

type quorum
relation member(N:node, Q:quorum)
type bset # blocking sets
relation bset_member(N:node, B:bset)
relation blocking(N:node, B:bset)

type value
type round

trusted isolate order_axioms = {
    instantiate value_order:totally_ordered(value)
    instantiate round_order:totally_ordered(round)
}

type ballot = struct {
    n:round,
    x:value
}

# TODO: this does not seem to work
# type statement = {abort, commit}
type statement
individual commit:statement
individual abort:statement
trusted isolate commit_neq_abort = {
    property commit ~= abort
}

# this isolate models what is proved in Isabelle/HOL:
trusted isolate federated_voting = {
    
    property intact(N1) & blocking(N1,B) -> exists N2 . intact(N2) & bset_member(N2,B)

    specification {
        
        relation vote(N:node, B:ballot, S:statement)
        relation accept(N:node, B:ballot, S:statement)
        relation confirm(N:node, B:ballot, S:statement)
        
        after init {
            vote(N,B,S) := false;
            accept(N,B,S) := false;
            confirm(N,B,S) := false;
        }
        
        action do_vote(n:node, b:ballot, s:statement) = {
            require ~(vote(n, b, S) & s ~= S);
            vote(n, b, s) := true
        }

        action do_accept(n:node, b:ballot, s:statement) = {
            require (exists Q . member(n,Q) & forall N . member(N,Q) -> (vote(N,b,s) | accept(N,b,s))) | (exists B . blocking(n,B) & forall N . bset_member(N,B) -> accept(N,b,s));
            accept(n, b, s) := true;
            ensure ~(intact(N1) & intact(N2) & accept(N1,b,S1) & accept(N2,b,S2) & S1 ~= S2);
        }

        action do_confirm(n:node, b:ballot, s:statement) = {
            require exists Q . member(n,Q) & forall N . member(N,Q) -> accept(N,b,s);
            confirm(n,b,s) := true;
            ensure ~(intact(N1) & intact(N2) & confirm(N1,b,S1) & confirm(N2,b,S2) & S1 ~= S2);
        }
    }
}

isolate ballot_order = {
    definition (B1 < B2) = (n(B1) < n(B2)) | (n(B1) = n(B2) & x(B1) < x(B2))
    definition (B1:ballot <= B2) = (B1 < B2 | B1 = B2)
    instantiate totally_ordered(ballot)    
} with order_axioms

isolate ballot_protocol = {
    
    relation vote(N:node, B:ballot, S:statement)
    relation accept(N:node, B:ballot, S:statement)
    relation confirm(N:node, B:ballot, S:statement)

    invariant [safety] ~(intact(N1) & intact(N2) & confirm(N1,B1,commit) & confirm(N2,B2,commit) & x(B1) ~= x(B2))

    # the main invariant:
    invariant ~(vote(N,B2,commit) & B1 < B2 & x(B1) ~= x(B2) & ~confirm(N,B1,abort))

    # validity properties:
    invariant ~(intact(N) & accept(N,B,S) & ~(exists N2 . intact(N2) & vote(N2,B,S)))
    invariant ~(intact(N) & confirm(N,B,S) & ~(exists N2 . intact(N2) & vote(N2,B,S)))

    # a node does not cast contradictory votes
    invariant ~(vote(N,B,S1) & vote(N,B,S2) & S1 ~= S2)

    # relation between protocol state and federated_voting state:
    invariant vote(N,B,S) = federated_voting.vote(N,B,S)
    invariant accept(N,B,S) = federated_voting.accept(N,B,S)
    invariant confirm(N,B,S) = federated_voting.confirm(N,B,S)

    # invariants implied by federated_voting:
    invariant ~(intact(N1) & intact(N2) & accept(N1,B,S1) & accept(N2,B,S2) & S1 ~= S2)
    invariant ~(intact(N1) & intact(N2) & confirm(N1,B,S1) & confirm(N2,B,S2) & S1 ~= S2)

    after init {
        vote(N,B,S) := false;
        accept(N,B,S) := false;
        confirm(N,B,S) := false;
    }

    action vote_abort(n:node, b:ballot) = {
        require ~(vote(n,b,S) & S ~= abort);
        vote(n,b,abort) := true;
        call federated_voting.do_vote(n,b,abort);
    }
    
    action vote_commit(n:node, b:ballot) = {
        require B < b & x(B) ~= x(b) -> confirm(n,B,abort);
        require ~(vote(n,b,S) & S ~= commit);
        vote(n,b,commit) := true;
        call federated_voting.do_vote(n,b,commit);
    }

    action do_accept(n:node, b:ballot, s:statement) = {
        require (exists Q . member(n,Q) & forall N . member(N,Q) -> (vote(N,b,s) | accept(N,b,s))) | (exists B . blocking(n,B) & forall N . bset_member(N,B) -> accept(N,b,s));
        accept(n,b,s) := true;
        call federated_voting.do_accept(n,b,s);
    }

    action do_confirm(n:node, b:ballot, s:statement) = {
        require exists Q . member(n,Q) & forall N . member(N,Q) -> accept(N,b,s);
        confirm(n,b,s) := true;
        call federated_voting.do_confirm(n,b,s);
    }

    export vote_abort
    export vote_commit
    export do_accept
    export do_confirm
    
} with ballot_order, federated_voting, commit_neq_abort


